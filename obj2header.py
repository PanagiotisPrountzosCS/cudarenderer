#!/usr/bin/env python3
"""
obj2header.py

Read a Wavefront .obj file and generate a C header containing
vertex and triangle arrays. Faces with >3 vertices are triangulated
using a fan. Indexing in OBJ (1-based, negative allowed) is handled.

Usage:
    python obj2header.py input.obj output.h [--prefix NAME]

The generated header is self-contained (defines `Vec3` and `Tri`).
"""
import sys
import os
import argparse


def parse_obj(path):
    verts = []
    faces = []
    with open(path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split()
            if parts[0] == 'v' and len(parts) >= 4:
                x = float(parts[1]); y = float(parts[2]); z = float(parts[3])
                verts.append((x, y, z))
            elif parts[0] == 'f' and len(parts) >= 4:
                # faces may be polygons; entries can be v, v/vt, v//vn, v/vt/vn
                idxs = []
                for ent in parts[1:]:
                    if '/' in ent:
                        vi = ent.split('/')[0]
                    else:
                        vi = ent
                    if vi == '':
                        continue
                    idxs.append(int(vi))
                if len(idxs) >= 3:
                    faces.append(idxs)
    return verts, faces


def to_zero_based(index, nverts):
    # OBJ: positive indices are 1-based, negative indices are relative to the end
    if index > 0:
        return index - 1
    else:
        return nverts + index


def triangulate_faces(faces, nverts):
    tris = []
    for face in faces:
        # convert to zero-based
        ids = [to_zero_based(i, nverts) for i in face]
        # fan triangulation
        a = ids[0]
        for i in range(1, len(ids) - 1):
            b = ids[i]
            c = ids[i + 1]
            tris.append((a, b, c))
    return tris


def make_guard(name):
    g = os.path.basename(name).upper()
    g = ''.join(ch if ch.isalnum() else '_' for ch in g)
    return g + '_'


def write_header(outpath, verts, tris, prefix='model', fixed_type=None):
    guard = make_guard(outpath)
    with open(outpath, 'w', encoding='utf-8') as f:
        f.write('/* Generated by obj2header.py */\n')
        f.write('#ifndef %s\n' % guard)
        f.write('#define %s\n\n' % guard)
        f.write('#ifdef __cplusplus\nextern "C" {\n#endif\n\n')
        f.write('#include <stdint.h>\n')
        if fixed_type is not None:
            f.write('#include "fixed.h"\n')
        f.write('\n')

        if fixed_type is not None:
            f.write('typedef struct { %s x, y, z; } Vec3;\n' % fixed_type)
        else:
            f.write('typedef struct { float x, y, z; } Vec3;\n')
        f.write('typedef struct { int a, b, c; } Tri;\n\n')

        vname = prefix + '_v'
        fname = prefix + '_f'

        f.write('static const Vec3 %s[] = {\n' % vname)
        if fixed_type is not None:
            # emit constructor-style initializers e.g. fxp16_t(1.23f)
            def fmt_f(v):
                s = '%g' % v
                # ensure integer values become '1.0f' instead of '1f'
                if ('.' in s) or ('e' in s) or ('E' in s):
                    return s + 'f'
                return s + '.0f'

            for x, y, z in verts:
                sx = fmt_f(x)
                sy = fmt_f(y)
                sz = fmt_f(z)
                f.write('    { %s(%s), %s(%s), %s(%s) },\n' % (fixed_type, sx, fixed_type, sy, fixed_type, sz))
        else:
            for x, y, z in verts:
                f.write('    { %g, %g, %g },\n' % (x, y, z))
        f.write('};\n\n')

        f.write('static const Tri %s[] = {\n' % fname)
        for a, b, c in tris:
            f.write('    { %d, %d, %d },\n' % (a, b, c))
        f.write('};\n\n')

        f.write('#ifdef __cplusplus\n}\n#endif\n\n')
        f.write('#endif /* %s */\n' % guard)


def main():
    p = argparse.ArgumentParser(description='Convert OBJ to C header (vertices + triangle faces).')
    p.add_argument('input', help='input OBJ file')
    p.add_argument('output', help='output header file')
    p.add_argument('--prefix', default='model', help='variable name prefix (default: model)')
    p.add_argument('--fixed', nargs='?', const='fxp16_t', choices=['fxp8_t', 'fxp16_t', 'fxp32_t'],
                   help='write vertex coordinates as fixed-point; optional type: fxp8_t, fxp16_t, fxp32_t (default when used: fxp16_t)')
    args = p.parse_args()

    verts, faces = parse_obj(args.input)
    if not verts:
        print('No vertices found in', args.input, file=sys.stderr)
        return 1
    tris = triangulate_faces(faces, len(verts))
    write_header(args.output, verts, tris, prefix=args.prefix, fixed_type=args.fixed)
    print('Wrote', args.output, ': %d verts, %d tris' % (len(verts), len(tris)))
    return 0


if __name__ == '__main__':
    sys.exit(main())
